// VSCode extensions that will make reading this file easier
// - rust-analyzer: Will tell you the type of many variables and allow for doccomments to work
// - BNF & EBNF Highlighting: Highlights all of the grammar files and syntax

// Load all of the magic code from boilerplate.rs. The goal is to make the code
// in this file cleaner, by dumping the messiness in some other file
mod boilerplate;
use boilerplate::*;

// Yes, you need to tell rust that you can compare enums using the `==`
// operator. Their enums are more powerful in other ways, fight me
/// The symbol a term is using. Either + (Add) or - (Sub)
#[derive(Debug, PartialEq)]
enum TermSymbol {
    Add,
    Sub,
}

/// The symbol used for factor eqns. Either * (Mul) or / (Div)
#[derive(Debug)]
enum FactorSymbol {
    Mul,
    Div,
}

// The output of each rule listed in grammar.ebnf
// Note that Box<x> means that we do not know the size of x
// derive(Debug) allows for the AST to be printed to the console
#[derive(Debug)]
enum Expr {
    Term(Box<Expr>, TermSymbol, Box<Expr>),
    Factor(Box<Expr>, FactorSymbol, Box<Expr>),
    Unary(TermSymbol, Box<Expr>),
    Group(Box<Expr>),
    Number(f32),
}

fn main() {
    // Load the expression from a text file
    let raw = std::fs::read_to_string("./expr.txt")
        .unwrap()
        .remove_whitespace();

    // Pass that expression into the expression parser.
    // Pro Tip: I am using doc comments. If you are reading this in vscode, go
    // install `rust-analyzer`, you will be able to hover over functions to
    // see what they do
    let (_, ast) = expression(raw);

    // Pretty print to the console. {} will be replaced with the contents of the
    // first param. :? will use debugging print statements. # will pretty print
    println!("{:#?}", ast);
}

/// The base rule of the expression. Really this is just an inbetween step to
/// make my code and EBNF files make more sense. Passes straight through to `term`
///
/// Note the return type, it will be common throughout the rest of the code.
/// This parser was implemented in something similar to the functional style.
/// Each function will take in a string, modify it, and return a new string for
/// the next parser to use. They will also return an expression
///
/// Based on the following rule:
/// ```ebnf
/// expression ::= term
/// ```
fn expression(raw: String) -> (String, Box<Expr>) {
    return term(raw);
}

/// Responsible for parsing basic addition and subtraction. Because it is at the
/// top of the stack, it has the lowest priority.
///
/// Based on the following rule:
/// ```ebnf
/// term ::= factor ['+' | '-' term]
/// ```
fn term(raw: String) -> (String, Box<Expr>) {
    // We should execute factor first, as described by the grammar rule
    //
    // Note on mut: within rust, you have to explicitly tell the compiler that a
    // variable can be changed. This is done with the `mut` keyword. Here, `raw`
    // is mutable, but `left` is immutable
    let (mut raw, left) = factor(raw);

    // If `'+' | '-'` does not match, we should return the value generated by
    // factor.
    if !(raw.starts_with("+") || raw.starts_with("-")) {
        return (raw, left);
    }

    // Convert the string into the enum that is required by Expr::Term.
    let operator = match raw.pop_first() {
        '+' => TermSymbol::Add,
        '-' => TermSymbol::Sub,
        // We have already checked for '+' or '-' above, so we do not need to
        // handle the case here
        _ => unreachable!(),
    };

    // We want to execute term on the left.
    // Whilst we are doing it because the grammar says to do it, the grammar says
    // to do it because it allows for the chaining of multiple terms (e.g. 1+2+3)
    let (raw, right) = term(raw);

    // Return both the modified string (mainly modified by pop_first) and the
    // enum
    return (
        raw,
        // Box puts the variable on the heap. This allows for the contents of
        // Box (i.e. Expr) to not have a size that is known at compile time.
        Box::new(
            // This is the rust method of constructing a tuple based enum. It
            // may look a bit funky, but think of it as a class invocation and
            // you will be fine.
            Expr::Term(left, operator, right),
        ),
    );
}

/// Responsible for handling multiplication and division. This function has a
/// higher priority than terms (addition and subtraction), but a lower priority
/// than unary (negations) or groups.
///
/// Based on the following rules:
/// ```ebnf
/// factor ::= unary ['/' | '*' factor]
/// ```
fn factor(raw: String) -> (String, Box<Expr>) {
    // Jump down to unary. It has a higher priority, so should be parsed before
    // the rest of this function
    let (mut raw, left) = unary(raw);

    // Just return the unary expression if it is not multiplication or division.
    // Either something below this function has already parsed it, or it will
    // be parsed by the term function above
    if !(raw.starts_with("*") || raw.starts_with("/")) {
        return (raw, left);
    }

    // Convert the first character of the string into an enum
    let operator = match raw.pop_first() {
        '*' => FactorSymbol::Mul,
        '/' => FactorSymbol::Div,
        // Because we already checked for other characters at the start, we know
        // it will either be * or /
        _ => unreachable!(),
    };

    // We want to repeat the factor to allow for chaining
    let (raw, right) = factor(raw);

    // Return the necessary values
    return (raw, Box::new(Expr::Factor(left, operator, right)));
}

/// Handles negated numbers. This function is also responsible for triggering
/// `group` and `number`
///
/// Based on the following rule:
/// ```ebnf
/// unary ::= ['+' | '-'] group | number | unary
/// ```
fn unary(mut raw: String) -> (String, Box<Expr>) {
    // Send groups of to a separate functions to be handled. If it is pretended
    // by a -, it will be sent through unary anyway. The grammar is cleaner if
    // this inconsistency is ignored.
    if raw.starts_with("(") {
        return group(raw);
    }

    // If it doesn't start with a + or a -, we should send it through to the
    // number parser to get parsed
    if !(raw.starts_with("-") || raw.starts_with("+")) {
        return number(raw);
    }

    let symbol = match raw.pop_first() {
        '+' => TermSymbol::Add,
        '-' => TermSymbol::Sub,
        // We have already filtered out non '+' and '-'
        _ => unreachable!(),
    };

    // Recursion time. Sends it back to handle the number, group and second
    // unary case.
    let (raw, num) = unary(raw);

    // Return all of th necessary values
    return (raw, Box::new(Expr::Unary(symbol, num)));
}

/// Handles everything within parenthesizes.
///
/// Based on the following rule:
/// ```ebnf
/// group ::= '(' expression ')'
/// ```
fn group(mut raw: String) -> (String, Box<Expr>) {
    // Must start with an opening bracket
    raw.remove_first_if_matches("(")
        .expect("Error when opening a group");

    // Jump all of the way back up to the expression function.
    // See? I told you that the expression function would make the code more
    // readable latter
    let (mut raw, expr) = expression(raw);

    // Check for closing bracket
    raw.remove_first_if_matches(")")
        .expect("Error when closing a group");

    // Return necessary values
    return (raw, Box::new(Expr::Group(expr)));
}

/// Converts a string to a number. Note that this ignores the number parser that
/// is defined within the grammar and just uses Rust's in built parser. Writing
/// a custom number parser is too much work for worse performance and more bugs.
fn number(raw: String) -> (String, Box<Expr>) {
    // Create a string we will store our final number within
    let mut number = String::new();
    // Convert the raw string into a characters array. This will make iteration
    // easier
    let mut chars = raw.trim().chars();

    // Time for jank, because I can't write number parsers to save my life.
    // The reason this exists is because the loop below will overshoot by one
    // character, which will get added to this char.
    let mut last = ' ';

    // Loop over the character list
    while let Some(c) = chars.next() {
        // If the character is not a valid base 10 digit, exit out of the loop
        if !c.is_digit(10) && c != '.' {
            // Store the overshot character.
            last = c;
            break;
        }

        // Otherwise add it to the number
        number.push(c);
    }

    return (
        // Add the overshot char to the start of the string and return it
        format!("{}{}", last, chars.as_string()).trim_string(),
        Box::new(
            // Use rust's internal number parser to convert the string to a float
            Expr::Number(number.convert()),
        ),
    );
}
